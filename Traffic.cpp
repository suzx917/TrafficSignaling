// author: szx917@gmail.com

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <map>
#include <set>
#include <algorithm>

using namespace std;

// arcs
struct Street { 
  int start;
  int end;
  string name;
  int cost;
};

inline ostream& operator<<(ostream& os, Street const& st) {
    os << "Street: " << st.start << "->" << st.end
      << " cost=" << st.cost << ", " << st.name;

    return os;
}

// nodes
struct Intersection { 
  vector<int> in; // in street ids
  vector<int> out; // out street ids   <- acutally this is useless

  inline int indeg() { return in.size(); }
  inline int outdeg() { return out.size(); }
};

// simulation units
struct Car {
  int progress = 0; // an index to its path seq for pos info
  int dist = 0; // to the end of the street
};

class Traffic {
  int status = -1; // -1 unintialized 0 map loaded 1 running simulation
  int D, I, S, V, F, B, E, C;
  string stname;
public:
  /*** base map data ***/
  map<string, int> nm2id; // mapping st names to ids

  vector<Street> streets;

  vector<vector<int>> paths; // for each path assign a sequence of st ids

  vector<Intersection> inters; // adj list of arcs (in/out street ids)

  /*** simulation utilities ***/
  vector<vector<int>> schedule; // lookup table for green lights - generated by strategy
                                // schedule[i][t] = green street of i-th intersection at t time 

  vector<Car> cars; // for each path assign a car recording dynamic positions

  vector<deque<int>> queues; // for each street assign a queue storing cars waiting at red lights

  /*** statistical data ***/
  // static (from map)
  set<int> inter_black;
  set<int> st_black;

  // dynamic (from simulation)
  vector<int> qtimes; // for each street, the sum value of waiting time in car-epochs, generated by a simulation

  /*** result ***/
  vector<vector<pair<int,int>>> strategy; // for each intersection assign a list of pairs < sid, duration >


  /*** I/Os and helpers ***/

  void output(ostream& os) { // output strategy in valid format
    os << I << '\n';
    for (int i = 0; i < I; ++i) {
      os << i << '\n';
      auto& row = strategy[i];
      os << row.size() << '\n';
      for (auto const& p: row) {
          os << streets[p.first].name << ' ' << p.second << '\n';
      }
    }
  }

  template <typename T>
  inline void prop(T& t) {
    cerr << "[" << t << "]\n";
  }

  void save(string fname) {
    ofstream ofs;
    ofs.open(fname);
    if (!ofs) {
      cerr << "Save: cannot open file " << fname << '\n';
      return;
    }
    output(ofs);
    ofs.close();
  }

  // !!! NOT TESTED !!!
  // read strategy from output file and evaluate score
  long eval(string fname) {
    if (status == -1)
      return -1;

    ifstream ifs;
    ifs.open(fname);
    
    int n, j, k, d;
    cin >> n;
    if (n != I) {
      cerr << "Eval: strategy file and model don't match\n";
    }

    for (int i = 0; i < n; ++i) {
      strategy[i].clear();
      cin >> j >> k;
      for (int ii = 0; ii < k; ++ii) {
        cin >> stname >> d;
      strategy[i].push_back(make_pair(nm2id[stname], d));
      }
    }

    long scr = run_sim();
    cerr << "Eval: " << fname << " score = ";
    prop(scr);

    ifs.close();
    return scr;
  }

  void dump() {
    cerr << "Schedule:\n";
    for (int i = 0; i < I; ++i) {
      cerr << "node #" << i << ": ";
      for (int j = 0; j < D+1; ++j) {
        cerr << schedule[i][j] << ' ';
      }
      cerr << '\n';
    }
  }

  /*** Traffic Simulation ***/

  void init_sim() {
    // cerr << "initializing simulation\n";
    // generate schedule table
    schedule = vector<vector<int>>(I, vector<int>(D+1,-1));

    for (int i = 0; i < I; ++i) {
      auto const& ref = strategy[i];

      if (!ref.empty()) {
        int offset = 0; // position in cycle list
        const int cycle = static_cast<int>(ref.size());

        int j = 0;
        while (j <= D) {
          int k = 0;
          while (k < ref[offset].second && j+k <= D) {
            schedule[i][j + k] = ref[offset].first;
            ++k;
          }
          offset = (offset + 1) % cycle;
          j += k;
        }
      }
    }
    // cerr << "Schedule:\n";
    // for (int i = 0; i < I; ++i) {
    //   cerr << "Node #" << i << ": ";
    //   for (int j = 0; j <= D; ++j) {
    //     cerr << schedule[i][j] << ' ';
    //   }
    //   cerr << '\n';
    // }

    // default car (id, path pos, st pos)
    cars = vector<Car>(V);

    // initialize queues
    queues = vector<deque<int>>(S);
    for (int i = 0; i < V; ++i) {
      const int sid = paths[i][0];
      queues[sid].push_back(i);
    }

    // statistics
    init_dynamic_stats();

    // dump();
  }

  long run_sim() {
    init_sim();
    long scr = 0;
    vector<bool> destroyed(V,false);
    // D total epochs
    for (int t = 0; t <= D; ++t) {
      cerr << ">> Epoch " << t << '\n';

      // if someone gets green light then block the following car from using it
      static vector<bool> updated(I, false); 
      
      for (int v = 0; v < V; ++v) {
        if (destroyed[v])
          continue;
        auto& car = cars[v];
        // case 1: trivial forward
        if (car.dist > 1) {
          --car.dist;
          continue;
        }
        // case 2: was waiting, check for green light
        else if (car.dist == 0){
          const int st = paths[v][car.progress];
          const int intsec = streets[st].end;
          if (queues[st].empty()) { // should not ever happen
            cerr << "Run Sim: wrong queueing" << endl;
          }
          // case 1: first in queue and green => transition and then block
          else if (schedule[intsec][t] == st && queues[st].front() == v && !updated[intsec]) {
            queues[st].pop_front();
            const int nextst = paths[v][++car.progress];
            car.dist = streets[nextst].cost;
            updated[intsec] = true;
            cerr << "Turn green #" << v << ' ' << streets[st].name << " -> " << streets[nextst].name << '\n';
          }
          // case 2 : remain queueing => increment stats
          else {
            ++qtimes[st];
          }
        }
        // case 3: dist == 1 check for goal condition or green light, otherwise register in queue
        else {
          if (car.progress == static_cast<int>(paths[v].size()-1)) {
            destroyed[v] = true;
            const long reward = F + D - t;
            cerr << "car #" << v << " reached dest! +" << reward << '\n';
            scr += reward;
            // prop(scr);
          }
          else {
            const int st = paths[v][car.progress];
            const int intsec = streets[st].end;

            // green light and no queue => fast transition
            if (schedule[intsec][t] == st && queues[st].empty() && !updated[intsec]) {
              const int nextst = paths[v][++car.progress];
              car.dist = streets[nextst].cost;
              cerr << "Fast trans #" << v << ' ' << streets[st].name << " -> " << streets[nextst].name << '\n';
            }
            // red light or has queue ahead => join queue
            else {
              queues[st].push_back(v);
              --car.dist;
            }
          }
        }
      }

      // reset
      fill(updated.begin(), updated.end(), false);

    } // end epoch for

    return scr;
  }

  /*** Initial Strategies ***/

  void clear_strategy() {
    strategy = vector<vector<pair<int,int>>>(I, vector<pair<int,int>>());
    cerr << "clear_strategy()\n";
  }

  void randomize(int seed) {
    srand(seed);
    for (int i = 0; i < I; ++i) {
      auto& row = inters[i].in;
      for (int j = 0; j < (int) row.size(); ++j) {
        if (rand() ^ (i*j) % 3)
          strategy[i].push_back(make_pair(row[j], rand() % row.size() + 1));
        else
          strategy[i].push_back(make_pair(row[j], 2));
      }
    }
  }

  // Give each in street k time, naive regular cycling
  void naive(int k) {
    clear_strategy();
    for (int i = 0; i < I; ++i) {
      auto& row = inters[i].in;
      for (int j = 0; j < (int) row.size(); ++j) {
        strategy[i].push_back(make_pair(row[j], k));
      }
    }
  }


  /*** Statistics and Strategy optimization ***/
  void init_dynamic_stats() {
    qtimes = vector<int>(S,0);
  }

  // strategize with some greedy static data
  void static_greedy() {  
    clear_strategy();
    // Do some basic statistics
    vector<int> st_s(S, 0); // popularity of street in terms of how many cars start from it
    vector<int> st_p(S, 0); // popularity of street in terms of how many paths contain it

    vector<int> path_len(V, 0); // total street length of each path

    for (int i = 0; i < V; ++i) {
      ++st_s[paths[i][0]];
      for (int s : paths[i]) {
        ++st_p[s];
        path_len[i] += streets[s].cost;
      }
      path_len[i] -= streets[paths[i][0]].cost;
    }

    // trying to find cars that will not reach destination in time, just jamming the system
    set<int> bad_paths;
    for (int i = 0; i < V; ++i) {
      if (path_len[i] > D) {
        bad_paths.insert(i);
        cerr << "Path #" << i << " bad! (len =" << path_len[i] << ")\n";
      }
    }

    // Notice: avoid optimization of:
    // 1. streets that will never be visited
    // 2. intersections that only have 1 in_degree (no options)

    for (int i = 0; i < I; ++i) {
      if (inters[i].indeg() < 1) {
        cerr << "Error: Indeg < 1 (#" << i << ")\n";
      }
      // boring intersections with indeg=1
      else if (inters[i].indeg() == 1) {
        strategy[i].push_back(make_pair(inters[i].in[0], 1));
        inter_black.insert(i); // add to black list
      }

      else {
        // sort streets based on starting positioning
        sort(inters[i].in.begin(), inters[i].in.end(),
          [&st_s](const int s1, const int s2){ return st_s[s1] > st_s[s2]; });

        // assign time based on path weights
        for (int j = 0; j < inters[i].indeg(); ++j) {
          int sid = inters[i].in[j];
          int weight = min(D, st_p[sid]);
          weight = max(1, weight);
          strategy[i].push_back(make_pair(sid, weight));
        }
      }
    }
  }

  void improve(int rep) {
    long maxscr, scr;
    
    naive(1);
    maxscr = run_sim();
    cerr << "naive(1) ";
    prop(maxscr);
    save("test.out");

    static_greedy();
    scr = run_sim();
    cerr << "static_greedy() ";
    prop(scr);

    if (maxscr < scr) {
      save("test.out");
      maxscr = scr;
    }

    for (int i = 1; i <= rep; ++i) {
      if (i % 5 == 1) {
        cerr << (double) i/rep * 100 << "%\t";
      }

      scr = run_sim();
      
      if (scr > maxscr) {
        maxscr = scr;
        cerr << "new high ";
        prop(scr);
        save("test.out");
      }
    }

    prop(maxscr);
  }


  Traffic() {
    // Read initial
    cin >> D >> I >> S >> V >> F; // [D]uration, [I]ntersections,
                                  // [S]treets, [V]ehicles, [F] bonus

    streets = vector<Street>(S);
    paths = vector<vector<int>>(V, vector<int>());

    for (int i = 0; i < S; ++i) {
      cin >> B >> E >> stname >> C;
      nm2id[stname] = i;
      streets[i] = Street{B,E,stname,C};
    }

    int P;
    for (int i = 0; i < V; ++i) {
      cin >> P;
      for (int j = 0; j < P; ++j) {
        cin >> stname;
        paths[i].push_back(nm2id[stname]);
      }
    }
    // Process node info
    inters = vector<Intersection>(I);

    for (int i = 0; i < S; ++i) {
      Street& st = streets[i];
      inters[st.start].out.push_back(i);
      inters[st.end].in.push_back(i);
    }

    improve(0);
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  Traffic t = Traffic();
  return 0;
}